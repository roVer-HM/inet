<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<analysis version="2">
    <inputs>
        <input pattern="/inet/showcases/wireless/aggregation/results/Aggregation-*.vec"/>
        <input pattern="/inet/showcases/wireless/aggregation/results/Aggregation-*.sca"/>
        <input pattern="/inet/showcases/wireless/aggregation/results/NoAggregation-#0.sca"/>
        <input pattern="/inet/showcases/wireless/aggregation/results/NoAggregation-#0.vec"/>
        <input pattern="/inet/showcases/wireless/aggregation/results/VoicePriorityAggregation-#0.*"/>
        <input pattern="/inet/showcases/wireless/aggregation/results/VoicePriorityBlockAckAggregation-#0.*"/>
        <input pattern="results/Delay*-#0.sca"/>
        <input pattern="results/Delay*-#0.vec"/>
    </inputs>
    <charts>
        <chart name="Number of packets received" script="# IDE version   5.4.1.181107-a953dcfb90&#10;&#10;import results&#10;import chart&#10;&#10;filter_string = &quot;&quot;&quot;((module(*.host2.app[0]) AND name(packetReceived:count)))&quot;&quot;&quot;&#10;&#10;df = results.getScalars(filter_string)&#10;&#10;print(df)&#10;&#10;df = results.pivotScalars(df, columns=[&quot;module&quot;], index=[&quot;configname&quot;])&#10;&#10;print(&quot;-----------------&quot;)&#10;&#10;print(df)&#10;&#10;df = df.reindex([&quot;NoAggregation&quot;,&quot;Aggregation&quot;,&quot;VoicePriorityAggregation&quot;])&#10;&#10;chart.plotScalars(df)&#10;&#10;chart.setProperty('Graph.Title', chart.getName())&#10;&#10;chart.setProperties(chart.getProperties())&#10;" type="BarChart">
            <property name="Graph.Title" value="Number of packets received"/>
            <property name="Legend.Display" value="false"/>
        </chart>
        <chart name="Average throughput" script="# IDE version   5.4.1.181107-a953dcfb90&#10;&#10;import results&#10;import chart&#10;import pandas as pd&#10;&#10;import operations as ops&#10;&#10;# This expression selects the results (you might be able to logically simplify it)&#10;filter_expression = &quot;&quot;&quot;&#10;ADD vectors WHERE attr:experiment(Aggregation) AND attr:replication(#0) AND module(AggregationShowcase.host2.app[0]) AND name(throughput:vector)&#10;ADD vectors WHERE attr:experiment(NoAggregation) AND attr:replication(#0) AND module(AggregationShowcase.host2.app[0]) AND name(throughput:vector)&#10;ADD vectors WHERE attr:experiment(VoicePriorityAggregation) AND attr:replication(#0) AND module(AggregationShowcase.host2.app[0]) AND name(throughput:vector)&#10;&quot;&quot;&quot;&#10;&#10;# The data is returned as a Pandas DataFrame&#10;df = results.getVectors(filter_expression)&#10;&#10;# Which we turn into a more usable format&#10;df = results.transform_results(df)&#10;&#10;# You can perform any transformations on the data here&#10;&#10;# convert to Mbps&#10;df.result.vecvalue /= 1000000&#10;&#10;# apply rolling mean&#10;for i in range(0,3):&#10;    throughput = pd.DataFrame(df.result.vecvalue[i])&#10;    res = throughput.rolling(window=10).mean()&#10;    rres = df.result.vecvalue[i] = res&#10;    # print(rres)&#10;    &#10;print(df.index.get_level_values('experiment'))&#10;&#10;names = list(df.index.get_level_values('experiment'))&#10;&#10;print(names)&#10;&#10;df[('attr','title')] = names&#10;&#10;# Finally, the results are plotted&#10;chart.plotVectors(df)&#10;" type="LineChart">
            <property name="Graph.Title" value="Average throughput"/>
            <property name="X.Axis.Title" value="Time [s]"/>
            <property name="Y.Axis.Title" value="Throughput [Mbps]"/>
        </chart>
        <chart name="End-to-end delay" script="# IDE version   5.4.1.181107-a953dcfb90&#10;&#10;import results&#10;import chart&#10;&#10;import operations as ops&#10;&#10;# This expression selects the results (you might be able to logically simplify it)&#10;filter_expression = &quot;&quot;&quot;&#10;ADD vectors WHERE attr:experiment(Aggregation) AND attr:replication(#0) AND module(AggregationShowcase.host2.app[0]) AND name(endToEndDelay:vector)&#10;ADD vectors WHERE attr:experiment(NoAggregation) AND attr:replication(#0) AND module(AggregationShowcase.host2.app[0]) AND name(endToEndDelay:vector)&#10;ADD vectors WHERE attr:experiment(VoicePriorityAggregation) AND attr:replication(#0) AND module(AggregationShowcase.host2.app[0]) AND name(endToEndDelay:vector)&#10;&quot;&quot;&quot;&#10;&#10;# The data is returned as a Pandas DataFrame&#10;df = results.getVectors(filter_expression)&#10;&#10;# Which we turn into a more usable format&#10;df = results.transform_results(df)&#10;&#10;df = ops.apply(df, ops.vector_multiply_by, 1000000) # You can change the multiplier constant&#10;# You can perform any transformations on the data here&#10;&#10;print(df.index.get_level_values('experiment'))&#10;&#10;names = list(df.index.get_level_values('experiment'))&#10;&#10;print(names)&#10;&#10;df[('attr','title')] = names&#10;&#10;# Finally, the results are plotted&#10;chart.plotVectors(df)&#10;" type="LineChart">
            <property name="Graph.Title" value="End-to-end delay"/>
            <property name="X.Axis.Title" value="Time [s]"/>
            <property name="Y.Axis.Title" value="End-to-end delay [us]"/>
        </chart>
        <chart name="Number of packets received (matplotlib)" script="# IDE version   5.4.1.181107-a953dcfb90&#10;&#10;import results&#10;import matplotlib.pyplot as plt&#10;&#10;df = results.getScalars(&quot;&quot;&quot;&#10;ADD scalars WHERE run(Aggregation-*) AND module(AggregationShowcase.host2.app[0]) AND name(packetReceived:count)&#10;ADD scalars WHERE run(NoAggregation-*) AND module(AggregationShowcase.host2.app[0]) AND name(packetReceived:count)&#10;ADD scalars WHERE run(VoicePriorityAggregation-*) AND module(AggregationShowcase.host2.app[0]) AND name(packetReceived:count)&#10;&#10;&quot;&quot;&quot;)&#10;&#10;df = results.pivotScalars(df, columns=[&quot;module&quot;], index=[&quot;configname&quot;])&#10;&#10;df = df.reindex([&quot;NoAggregation&quot;,&quot;Aggregation&quot;,&quot;VoicePriorityAggregation&quot;])&#10;&#10;ax = df.plot(kind='bar', zorder=2, align='center', width=0.8, figsize=(8,6))&#10;plt.legend().remove()&#10;plt.title(&quot;&quot;&quot;Number of packets received&quot;&quot;&quot;)&#10;#plt.tight_layout()&#10;&#10;plt.grid(b=True, which='major', axis='y', linestyle='--')&#10;plt.grid(b=True, which='minor', axis='y', linestyle='None')&#10;#plt.minorticks_on()&#10;plt.xticks(rotation=0)&#10;plt.xlabel(&quot;&quot;)&#10;&#10;for p in ax.patches:&#10;    ax.annotate(str(p.get_height()), (p.get_x() + p.get_width() / 2, p.get_height() - 10000),&#10;                horizontalalignment='center', verticalalignment='top', color='white', size=12)&#10;&#10;&#10;print(ax)&#10;&#10;plt.savefig('rcvdpackets.png', dpi=120, bbox_inches='tight')&#10;plt.savefig('rcvdpackets_t.png', dpi=120, bbox_inches='tight', transparent=True)&#10;" type="MatplotlibChart"/>
        <chart name="Average throughput (matplotlib)" script="# IDE version   5.4.1.181107-a953dcfb90&#10;&#10;import results&#10;import matplotlib.pyplot as plt&#10;import pandas as pd&#10;from matplotlib.pyplot import ylim&#10;import re&#10;import numpy as np&#10;&#10;df_orig = results.getVectors(&quot;&quot;&quot;&#10;ADD vectors WHERE run(Aggregation-*) AND module(AggregationShowcase.host2.app[0]) AND name(throughput:vector)&#10;ADD vectors WHERE run(NoAggregation-*) AND module(AggregationShowcase.host2.app[0]) AND name(throughput:vector)&#10;ADD vectors WHERE run(VoicePriorityAggregation-*) AND module(AggregationShowcase.host2.app[0]) AND name(throughput:vector)&#10;&#10;&quot;&quot;&quot;)&#10;df = df_orig[df_orig.type == 'vector']&#10;runsdf = df_orig[(df_orig.type == 'runattr') &amp; (df_orig.attrname == 'configname')]&#10;&#10;runsdf = runsdf[['run','attrvalue']].set_index('run')&#10;runsdf = runsdf.rename(columns={'attrvalue': 'experiment'})&#10;&#10;print(&quot;df3:&quot;,runsdf)&#10;&#10;# print(&quot;df:&quot;, df)&#10;&#10;#df.set_index('run').join(df3, on='run')&#10;&#10;# print(&quot;-------------------------------&quot;)&#10;&#10;# left join - join runsdf to df with run column in runsdf as key, suffix df's column&#10;vectorsdf = df.join(runsdf, on=&quot;run&quot;, lsuffix=&quot;_dummy&quot;)&#10;# print(vectorsdf)&#10;&#10;# print(&quot;'''''''''''''''''''''''''''''''''''''''''''''''&quot;)&#10;&#10;# df2 = results.transform_results(df_orig)&#10;&#10;# print(&quot;df2&quot;,df2)&#10;&#10;#names = df2.index.get_level_values('experiment')&#10;names = vectorsdf.experiment&#10;&#10;df[('name')] = names&#10;&#10;ind = df.vecvalue.index&#10;# print(&quot;ind:&quot;)&#10;# print(ind)&#10;&#10;for i in ind:&#10;    # print(df.vecvalue[i])&#10;    #throughput = df.vecvalue[i]&#10;    throughput1 = df.vecvalue[i].byteswap().newbyteorder()&#10;    throughput = pd.DataFrame(throughput1)&#10;#    avg = throughput.rolling(window=10).mean().fillna(throughput)&#10;    avg = throughput.rolling(window=10, min_periods=1).mean()&#10;    # print(avg)&#10;    df.vecvalue[i] = avg/1000000&#10;&#10;# for i in df.vecvalue:&#10;#     throughput = df.vecvalue[i]&#10;#     #print(throughput)&#10;#     res = throughput.rolling(window=10).mean()&#10;#     print(res)&#10;#     df.vecvalue[i] = res&#10;&#10;print(df)&#10;&#10;plt.figure(figsize=(8,6))&#10;&#10;plt.xlabel('Simulation time [s]', fontsize=12)&#10;plt.ylabel('Throughput [Mbps]', fontsize=12)&#10;&#10;# #1f77b4 -&gt; blue&#10;# #ff7f0e -&gt; orange&#10;# #2ca02c -&gt; green&#10;&#10;newcolors = ['#2ca02c', '#ff7f0e', '#1f77b4']&#10;&#10;array_of_colors = np.array([['NoAggregation','#1f77b4'], ['Aggregation','#ff7f0e'], ['VoicePriorityAggregation','#2ca02c']])&#10;print(array_of_colors)&#10;&#10;colordf = pd.DataFrame(array_of_colors, index=None, columns=['name','color'])&#10;print('colordf:',colordf)&#10;&#10;colordf = colordf[['name','color']].set_index('name')&#10;print(&quot;the new colordf:&quot;, colordf)&#10;&#10;df = df.join(colordf, on='name')&#10;&#10;&#10;print('df', df)&#10;&#10;print('the color part of df:', df.color)&#10;&#10;j = 0&#10;for t in df[['vectime', 'vecvalue', 'name', 'color']].itertuples(index=False):&#10;    plt.plot(t[0], t[1], label=(t[2]), drawstyle='steps-post', color=t[3])&#10;    j = j + 1&#10;plt.legend()&#10;plt.title(&quot;&quot;&quot;Average throughput&quot;&quot;&quot;, fontsize=14)&#10;plt.tight_layout()&#10;&#10;plt.ticklabel_format(style='plain', axis='y', scilimits=(0,0))&#10;&#10;# plt.grid(axis='both', which='both')&#10;plt.grid(b=True, which='major', axis='both', linestyle='--')&#10;plt.grid(b=True, which='minor', axis='both', linestyle='None')&#10;plt.minorticks_on()&#10;&#10;#plt.Axes.ticklabel_format(*, axis='both', style='')&#10;&#10;# print(df_orig.index.get_level_values('experiment'))&#10;&#10;# increase y top by 20% (so the legend doesn't overlap with the chart)&#10;bottom, top = ylim()&#10;range = top-bottom&#10;newytop = top + 0.2 * range&#10;ylim(top=newytop)&#10;&#10;plt.xlim(0,10)&#10;plt.ylim(bottom=0)&#10;&#10;ax = plt.gca()&#10;yticks = ax.yaxis.get_major_ticks()&#10;yticks[0].label1.set_visible(False)&#10;&#10;# print(plt.yticks()[0][0].set_visible(False))&#10;&#10;ax = plt.gca()&#10;handles, labels = ax.get_legend_handles_labels()&#10;&#10;# get current colors&#10;colors = []&#10;for i in handles:&#10;    print(colors.append(i.get_color()))&#10;# print(colors)&#10;&#10;# set legend colors    &#10;j = 0&#10;&#10;#for i in handles:&#10;#    if(labels[j] == 'VoicePriorityAggregation'):&#10;#        print(&quot;voicepriority&quot;, labels[j])&#10;#        i.set_color('#2ca02c')&#10;#    if(labels[j] == 'Aggregation'):&#10;#        print(&quot;aggregation&quot;, labels[j])&#10;#        i.set_color('#ff7f0e')&#10;#    if(labels[j] == 'NoAggregation'):&#10;#        print(&quot;noaggregation&quot;, labels[j])&#10;#        i.set_color('#1f77b4')&#10;#    j = j + 1&#10;&#10;# reorder legend&#10;print(&quot;labels:&quot;,labels)&#10;&#10;newlabels = [0,1,2]&#10;newhandles = [0,1,2]&#10;&#10;j = 0&#10;for i in labels:&#10;    if(i == 'NoAggregation'):&#10;        newlabels[0] = i&#10;        newhandles[0] = handles[j]&#10;    if(i == 'Aggregation'):&#10;        newlabels[1] = i&#10;        newhandles[1] = handles[j]&#10;    if(i == 'VoicePriorityAggregation'):&#10;        newlabels[2] = i&#10;        newhandles[2] = handles[j]&#10;    j = j + 1&#10;        &#10;print(&quot;newlabels:&quot;, newlabels)&#10;&#10;labels = newlabels&#10;handles= newhandles&#10;ax.legend(handles,labels)&#10;&#10;plt.savefig('avgthroughput.png', dpi=150)&#10;plt.savefig('avgthroughput_t.png', dpi=150, transparent=True)&#10;&#10;# plt.savefig('chart.png', dpi=150, transparent=True)" type="MatplotlibChart"/>
        <chart name="End-to-end delay (matplotlib)" script="# IDE version   5.4.1.181107-a953dcfb90&#10;&#10;import results&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;import pandas as pd&#10;&#10;df_orig = results.getVectors(&quot;&quot;&quot;&#10;ADD vectors WHERE run(Aggregation-*) AND module(AggregationShowcase.host2.app[0]) AND name(endToEndDelay:vector)&#10;ADD vectors WHERE run(NoAggregation-*) AND module(AggregationShowcase.host2.app[0]) AND name(endToEndDelay:vector)&#10;ADD vectors WHERE run(VoicePriorityAggregation-*) AND module(AggregationShowcase.host2.app[0]) AND name(endToEndDelay:vector)&#10;&#10;&quot;&quot;&quot;)&#10;df = df_orig[df_orig.type == 'vector']&#10;&#10;plt.figure(figsize=(16,8))&#10;&#10;plt.xlabel('Simulation time [s]', fontsize=12)&#10;plt.ylabel('End-to-end delay [s]', fontsize=12)&#10;&#10;df2 = results.transform_results(df_orig)&#10;&#10;runsdf = df_orig[(df_orig.type == 'runattr') &amp; (df_orig.attrname == 'configname')]&#10;&#10;runsdf = runsdf[['run','attrvalue']].set_index('run')&#10;runsdf = runsdf.rename(columns={'attrvalue': 'experiment'})&#10;&#10;# print(&quot;df3:&quot;,runsdf)&#10;&#10;# print(&quot;df:&quot;, df)&#10;&#10;#df.set_index('run').join(df3, on='run')&#10;&#10;# print(&quot;-------------------------------&quot;)&#10;&#10;# left join - join runsdf to df with run column in runsdf as key, suffix df's column&#10;vectorsdf = df.join(runsdf, on=&quot;run&quot;, lsuffix=&quot;_dummy&quot;)&#10;# print(vectorsdf)&#10;&#10;# print(&quot;'''''''''''''''''''''''''''''''''''''''''''''''&quot;)&#10;&#10;# df2 = results.transform_results(df_orig)&#10;&#10;# print(&quot;df2&quot;,df2)&#10;&#10;#names = df2.index.get_level_values('experiment')&#10;names = vectorsdf.experiment&#10;&#10;df[('name')] = names&#10;&#10;#names = df2.index.get_level_values('experiment')&#10;&#10;#df[('name')] = names&#10;&#10;# set colors&#10;newcolors = ['#2ca02c', '#ff7f0e', '#1f77b4']&#10;&#10;array_of_colors = np.array([['NoAggregation','#1f77b4'], ['Aggregation','#ff7f0e'], ['VoicePriorityAggregation','#2ca02c']])&#10;print(array_of_colors)&#10;&#10;colordf = pd.DataFrame(array_of_colors, index=None, columns=['name','color'])&#10;print('colordf:',colordf)&#10;&#10;colordf = colordf[['name','color']].set_index('name')&#10;print(&quot;the new colordf:&quot;, colordf)&#10;&#10;df = df.join(colordf, on='name')&#10;&#10;print(df)&#10;&#10;&#10;j = 0&#10;for t in df[['vectime', 'vecvalue', 'name', 'color']].itertuples(index=False):&#10;    plt.plot(t[0], t[1], 's', markersize=3, label=(t[2]), drawstyle='default', color=t[3])&#10;plt.legend(fontsize=12)&#10;plt.title(&quot;&quot;&quot;End-to-end delay&quot;&quot;&quot;, fontsize=14)&#10;plt.tight_layout()&#10;plt.grid(True, 'both', 'both', linestyle='--')&#10;&#10;print(&quot;gca&quot;)&#10;ax = plt.gca()&#10;print(ax)&#10;&#10;# plt.xticks(fontsize=14, rotation=90)&#10;&#10;plt.xticks(fontsize=10)&#10;plt.yticks(fontsize=10)&#10;&#10;# zoom level change event handling&#10;def on_xlims_change(axes):&#10;    print(&quot;plt.xlim&quot; + str(ax.get_xlim()))&#10;&#10;def on_ylims_change(axes):&#10;    print(&quot;plt.ylim&quot; + str(ax.get_ylim()))&#10;    &#10;ax.callbacks.connect('xlim_changed', on_xlims_change)&#10;ax.callbacks.connect('ylim_changed', on_ylims_change)&#10;&#10;# set xlim/ylim here to get a specific zoom level image&#10;#plt.xlim(2.3913301414162063, 2.401084119226868)&#10;#plt.ylim(0, 0.0017121831300160421)&#10;&#10;left, right = plt.xlim()&#10;bottom, top = plt.ylim()&#10;&#10;print(left)&#10;print(right)&#10;print(bottom)&#10;print(top)&#10;&#10;plt.ylim(bottom,top*1.1)&#10;&#10;handles, labels = ax.get_legend_handles_labels()&#10;# reorder legend&#10;print(&quot;labels:&quot;,labels)&#10;&#10;newlabels = [0,1,2]&#10;newhandles = [0,1,2]&#10;&#10;j = 0&#10;for i in labels:&#10;    if(i == 'NoAggregation'):&#10;        newlabels[0] = i&#10;        newhandles[0] = handles[j]&#10;    if(i == 'Aggregation'):&#10;        newlabels[1] = i&#10;        newhandles[1] = handles[j]&#10;    if(i == 'VoicePriorityAggregation'):&#10;        newlabels[2] = i&#10;        newhandles[2] = handles[j]&#10;    j = j + 1&#10;        &#10;print(&quot;newlabels:&quot;, newlabels)&#10;&#10;labels = newlabels&#10;handles= newhandles&#10;ax.legend(handles,labels)&#10;&#10;#plt.savefig('delay8.png', dpi=150, facecolor='#fafafa', edgecolor='#fafafa')&#10;plt.savefig('delay8_t.png', dpi=150, transparent=True)&#10;" type="MatplotlibChart"/>
    </charts>
</analysis>
